---
layout: page
title: Shell江湖不用刀，正则表达式开路
tags:
 - Linux
 - Shell
---
Shell是Linux下的一个程序，负责与kernel交互。同时，也是一种语言，通过指令集调动kernel。想要学习Shell，正则表达式必不可少。

\：表示下一个字符的标记符、一个向后引用或一个八进制转义符。例如：“\\t”匹配“\t”，“\t”表示一个制表符。通常称“\”为转义符。

^: 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，则“^”匹配“\n”或“\r”之后的位置。

$: 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属相，则“$”匹配“\n”或“\r”之前的位置。

*: 匹配前面的子表达式任意次。例如, “mp*”能匹配“m”、“mp”以及“mpp”，等价于{0,}。

+: 匹配前面的子表达式一次或多次（至少有一次）。例如，“mp+”能匹配“mp”、“mpp”，但是不能匹配“m”，等价于{1,}。

?: 匹配前面的子表达式0次或1次。例如，“ze(ro)?”可以匹配“ze”和“zero”中的“ze”，等价于{0, 1}。

{n}: n是一个非负整数，匹配确定的n次。例如，“l{2}”不能匹配“love”中的“l”，但是能匹配“Hello”中的“ll”。

{n,}: n是一个非负整数，表示至少匹配n次。例如，“u{2}”不能匹配“up”中的“u”，但是能匹配“uuuuuup”中的“u”。

{n,m}: n,m是一个非负整数，且m>=n，表示最少匹配n次，最多匹配m次。例如，“u{1,3}”将匹配“uuuuup”中的前3个“u”。注意，“n”、“,”、“m”中间不能有空格。

?组合：当该字符紧跟在任何一个其他限制符（如*、+、?、{n,}、{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式表示尽可能少的匹配所搜索的字符串，而默认的贪婪模式则是尽可能多的匹配所搜索的字符串。例如，对于字符串“uuuuuuu”，“u+?”将匹配单个“u”，而“u+”将匹配所有“u”。

.: 匹配除了“\r\n”之外的任何单个字符。若要匹配包括“\r\n”在内的任何字符，请使用类似于“[\s\S]”的模式。

(): 将正则表达式的一部分括起来组成一个单元，可以对整个单元使用数量限定符。例如，要搜索“glad”或“good”，可以使用“g(ld&#124;oo)d”，()的好处是可以对组合串使用“+”、“?”、“*”等。如使用“([0-9]{1,3}\.){3}[0-9]{1,3}”可以匹配ip地址。

&#124;: 或匹配，例如，“a&#124;b”，匹配“a”或者“b”，再例如，“z&#124;foo”能够匹配“z”或“foo”或“zoo”，“(z&#124;f)oo”则匹配“zoo”或“foo”。

[xyz]: 字符集合。匹配所包含的任意一个字符。例如，“[xyz]”匹配“Linux”中的“x”。

[^xyz]: 负值字符集合，匹配未包含的任意字符。例如，“[xyz]”可以匹配“Linux”中的“Linu”。

[a-z]: 字符范围，匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。需要注意：“-”只有出现在两个字符之间时，才表示字符范围，出现在字符组的开头，只能表示连字符本身。

[^a-z]: 负值字符范围，匹配任何不在指定范围内的任意字符。例如，“[^a-z]”匹配不在“a”到“z”范围内的任意字符。

\b: 匹配一个单词边界，也就是单词和空格之间的位置（正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置。这里的“\b”就是匹配位置）例如，“er\b”可以匹配“never”中的“er”，不能匹配“verb”中的“er”。

\B: 匹配非单词边界。例如，“er\B”能匹配“verb”中的“er”，不能匹配“never”中的“er”。

\d: 匹配一个数字字符，等价于“[0-9]”。

\D: 匹配一个非数字字符，等价于“[^0-9]”。

\f: 匹配一个换页符，等价于“\x0c”和“\cL”。

\n: 匹配一个换行符，等价于“\x0a”和“\cJ”。

\r: 匹配一个回车符，等价于“\x0d”和“\cM”。

\s: 匹配任何不可见字符，包括空格、制表符、换页符，等等。等价于“[\f\n\r\t\v]”。

\S: 匹配任何可见字符，等价于“[^\f\n\r\t\v]”。

\t: 匹配一个制表符。

\v: 匹配一个垂直制表符。

\w: 匹配包括下划线的任何单词字符。

\W: 匹配任何非单词字符。等价于“[^A-Za-z0-9]”。


